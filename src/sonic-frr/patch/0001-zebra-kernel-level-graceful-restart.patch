 zebra: Add kernel level graceful restart

 <Initial Code from Praveen Chaudhary>

 Add the a `--graceful_restart X` flag to zebra start that
 now creates a timer that pops in X seconds and will go
 through and remove all routes that are older than startup.

 If graceful_restart is not specified then we will just pop
 a timer that cleans everything up immediately.

 Signed-off-by: Praveen Chaudhary <pchaudhary@linkedin.com>
 Signed-off-by: Donald Sharp <sharpd@cumulusnetworks.com>

diff --git a/zebra/main.c b/zebra/main.c
index 19b1693..5b07585 100644
--- a/zebra/main.c
+++ b/zebra/main.c
@@ -68,8 +68,7 @@ int retain_mode = 0;
 /* Allow non-quagga entities to delete quagga routes */
 int allow_delete = 0;
 
-/* Don't delete kernel route. */
-int keep_kernel_mode = 0;
+int graceful_restart;
 
 #ifdef HAVE_NETLINK
 /* Receive buffer size for netlink socket */
@@ -79,11 +78,11 @@ u_int32_t nl_rcvbufsize = 4194304;
 /* Command line options. */
 struct option longopts[] = {{"batch", no_argument, NULL, 'b'},
 			    {"allow_delete", no_argument, NULL, 'a'},
-			    {"keep_kernel", no_argument, NULL, 'k'},
 			    {"socket", required_argument, NULL, 'z'},
 			    {"ecmp", required_argument, NULL, 'e'},
 			    {"label_socket", no_argument, NULL, 'l'},
 			    {"retain", no_argument, NULL, 'r'},
+			    {"graceful_restart", required_argument, NULL, 'K'},
 #ifdef HAVE_NETLINK
 			    {"nl-bufsize", required_argument, NULL, 's'},
 #endif /* HAVE_NETLINK */
@@ -205,10 +204,11 @@ int main(int argc, char **argv)
 	char *fuzzing = NULL;
 #endif
 
+	graceful_restart = 0;
 	frr_preinit(&zebra_di, argc, argv);
 
 	frr_opt_add(
-		"bakz:e:l:r"
+		"baz:e:l:rK:"
 #ifdef HAVE_NETLINK
 		"s:"
 #endif
@@ -217,18 +217,18 @@ int main(int argc, char **argv)
 #endif
 		,
 		longopts,
-		"  -b, --batch        Runs in batch mode\n"
-		"  -a, --allow_delete Allow other processes to delete zebra routes\n"
-		"  -z, --socket       Set path of zebra socket\n"
-		"  -e, --ecmp         Specify ECMP to use.\n"
-		"  -l, --label_socket Socket to external label manager\n"
-		"  -k, --keep_kernel  Don't delete old routes which installed by zebra.\n"
-		"  -r, --retain       When program terminates, retain added route by zebra.\n"
+		"  -b, --batch              Runs in batch mode\n"
+		"  -a, --allow_delete       Allow other processes to delete zebra routes\n"
+		"  -z, --socket             Set path of zebra socket\n"
+		"  -e, --ecmp               Specify ECMP to use.\n"
+		"  -l, --label_socket       Socket to external label manager\n"
+		"  -r, --retain             When program terminates, retain added route by zebra.\n"
+		"  -K, --graceful_restart   Graceful restart at the kernel level, timer in seconds for expiration\n"
 #ifdef HAVE_NETLINK
-		"  -s, --nl-bufsize   Set netlink receive buffer size\n"
+		"  -s, --nl-bufsize         Set netlink receive buffer size\n"
 #endif /* HAVE_NETLINK */
 #if defined(HANDLE_ZAPI_FUZZING)
-		"  -c <file>          Bypass normal startup use this file for tetsting of zapi"
+		"  -c <file>                Bypass normal startup use this file for tetsting of zapi"
 #endif
 		);
 
@@ -247,9 +247,6 @@ int main(int argc, char **argv)
 		case 'a':
 			allow_delete = 1;
 			break;
-		case 'k':
-			keep_kernel_mode = 1;
-			break;
 		case 'e':
 			multipath_num = atoi(optarg);
 			if (multipath_num > MULTIPATH_NUM
@@ -275,6 +272,9 @@ int main(int argc, char **argv)
 		case 'r':
 			retain_mode = 1;
 			break;
+		case 'K':
+			graceful_restart = atoi(optarg);
+			break;
 #ifdef HAVE_NETLINK
 		case 's':
 			nl_rcvbufsize = atoi(optarg);
@@ -351,8 +351,10 @@ int main(int argc, char **argv)
 	*  will be equal to the current getpid(). To know about such routes,
 	* we have to have route_read() called before.
 	*/
-	if (!keep_kernel_mode)
-		rib_sweep_route();
+	struct zebra_ns *zns = zebra_ns_lookup(NS_DEFAULT);
+	zns->startup_time = monotime(NULL);
+	thread_add_timer(zebrad.master, rib_sweep_route,
+		NULL, graceful_restart, NULL);
 
 	/* Needed for BSD routing socket. */
 	pid = getpid();
diff --git a/zebra/rib.h b/zebra/rib.h
index 664afd0..091acd5 100644
--- a/zebra/rib.h
+++ b/zebra/rib.h
@@ -320,7 +320,7 @@ extern struct route_entry *rib_lookup_ipv4(struct prefix_ipv4 *, vrf_id_t);
 
 extern void rib_update(vrf_id_t, rib_update_event_t);
 extern void rib_weed_tables(void);
-extern void rib_sweep_route(void);
+extern int  rib_sweep_route(struct thread *t);
 extern void rib_close_table(struct route_table *);
 extern void rib_init(void);
 extern unsigned long rib_score_proto(u_char proto, u_short instance);
diff --git a/zebra/zebra_ns.h b/zebra/zebra_ns.h
index 5d90b9b..1e5a136 100644
--- a/zebra/zebra_ns.h
+++ b/zebra/zebra_ns.h
@@ -55,6 +55,11 @@ struct zebra_ns {
 #if defined(HAVE_RTADV)
 	struct rtadv rtadv;
 #endif /* HAVE_RTADV */
+
+	/*
+	 * Time for when we sweep the rib from old routes
+	 */
+	 time_t startup_time;
 };
 
 struct zebra_ns *zebra_ns_lookup(ns_id_t ns_id);
diff --git a/zebra/zebra_rib.c b/zebra/zebra_rib.c
index b7b4a15..e99c543 100644
--- a/zebra/zebra_rib.c
+++ b/zebra/zebra_rib.c
@@ -2716,12 +2716,14 @@ static void rib_sweep_table(struct route_table *table)
 	struct route_entry *re;
 	struct route_entry *next;
 	struct nexthop *nexthop;
+	struct zebra_ns *zns = zebra_ns_lookup(NS_DEFAULT);
 
 	if (!table)
 		return;
 
 	for (rn = route_top(table); rn; rn = srcdest_route_next(rn)) {
 		RNODE_FOREACH_RE_SAFE (rn, re, next) {
+
 			if (IS_ZEBRA_DEBUG_RIB)
 				route_entry_dump(&rn->p, NULL, re);
 
@@ -2732,6 +2734,14 @@ static void rib_sweep_table(struct route_table *table)
 				continue;
 
 			/*
+			 * If routes are older than startup_time then
+			 * we know we read them in from the kernel.
+			 * As such we can safely remove them.
+			 */
+			if (zns->startup_time < re->uptime)
+				continue;
+
+			/*
 			 * So we are starting up and have received
 			 * routes from the kernel that we have installed
 			 * from a previous run of zebra but not cleaned
@@ -2759,7 +2769,7 @@ static void rib_sweep_table(struct route_table *table)
 }
 
 /* Sweep all RIB tables.  */
-void rib_sweep_route(void)
+int rib_sweep_route(struct thread *t)
 {
 	struct vrf *vrf;
 	struct zebra_vrf *zvrf;
@@ -2771,6 +2781,8 @@ void rib_sweep_route(void)
 		rib_sweep_table(zvrf->table[AFI_IP][SAFI_UNICAST]);
 		rib_sweep_table(zvrf->table[AFI_IP6][SAFI_UNICAST]);
 	}
+
+	return 0;
 }
 
 /* Remove specific by protocol routes from 'table'. */
